---
layout: nocomment-post
categories: [meta]
title: About
post_author: Paul Chiusano
---

Software isn't living up to its potential. Programmers still use tools whose constraints [come from the punchcard era](http://pchiusano.github.io/2014-09-30/punchcard-era.html) and users have accepted that [computing is organized as a constellation of rigid software appliances](http://pchiusano.github.io/2013-05-22/future-of-software.html) ("apps") that never seem to work well together and certainly can't be composed or extended. The software world is swimming in a sea of accidental complexity caused by 40 years of accumulated technical debt.

The result of all this is that most of the time people spend building software is wasted on repeatedly solving uninteresting problems, artificially created due to bad foundational assumptions:

* Perhaps 70% of developer time is spent dealing with parsing, serialization, and persistence. Values are encoded to and from JSON, to and from various binary formats, and to and from various persistent data stores... over and over again.
* Another 25% is spent on explicit networking. We don't merely specify _that_ a value must be sent from one node to another, we also specify _how_ in exhaustive detail.
* Somewhere in between all this plumbing code is a tiny amount of interesting, pure computation, which takes up the remaining 5% of developer time. And there's very little reuse of that 5% across applications, because every app is wrapped in a different 95% of cruft and the useful logic is often difficult to separate!

These numbers are made up, of course, but if anything they are _optimistic_. And let's also not forget the huge amount of time spent on making a sane (or even pleasing, logical) UI, which imposes yet another parsing boundary since meaningful values must be 'parsed' from the untyped interactions and views of the UI!

Thus, tasks that "should be" easy take months. Features that "should" exist don't. Systems that could profitably talk to each other rarely do. And writing scalable, distributed software systems, which access data and functions from multiple sources and execute computations over clusters of nodes, is reserved mainly for companies with huge budgets and armies of developers. Is this really the best humanity can do?

Unison is a new, open platform which reimagines how users interact with software, how developers build and organize it, and how we build the UIs that serve as the window to software functionality. The project pulls together some of the best research and ideas in computing developed over the past 40 years, which just need love and dedicated effort to assemble into a practical, integrated whole that everyone can use. Building useful software systems and the UIs that drive them ought to be vastly easier. And the software artifacts we build ought to be able to talk to each other easily while remaining extensible and composable _by default_.

What is the Unison platform? At a high level, it consists of three components:

* The Unison _language_: a powerful, typed, purely functional underlying programming language
* The Unison _editor_: a rich, in-browser [semantic editor](http://pchiusano.github.io/2014-09-30/punchcard-era.html) for editing programs
* The Unison _node_: the backend implementation of the Unison language, its typechecker, and the API used by the Unison editor and other remote nodes in the network

The collection of Unison nodes (the _Unison web_) form a network platform in which data _and functions_ may be trivially exchanged, with a minimum of friction.

[The code is open source](https://github.com/unisonweb/platform) and [MIT licensed](https://github.com/unisonweb/platform/blob/master/LICENSE). The hope is ultimately that Unison can serve as a common open platform that lets different software systems to talk to one another, a high-level glue that connects the software systems of our civilization and lets them easily share and transmit data and computations, without resorting to lowest common denominator interoperability like JSON or XML over HTTP.

### <a id="tech-overview"/> Technical overview

Much of the complexity in the software world is the result of foundational assumptions, many of which date back to the [punchcard era](http://pchiusano.github.io/2014-09-30/punchcard-era.html) or [the pre-software age](http://pchiusano.github.io/2013-05-22/future-of-software.html) and have [never been revisited](http://pchiusano.github.io/2014-11-13/program-as-ui.html#remarks). By making new foundational assumptions, many problems become simpler to deal with or are sidestepped entirely.

Let's look at some of the premises adopted by Unison:

* _Programs are edited in a (browser-based) [semantic editor](http://pchiusano.github.io/2014-09-30/punchcard-era.html) which guarantees programs are well-formed and typecheck by construction_. There are no parse or type errors to report to the user, since the UI constrains edits to those that are well-typed. With some care and thought, this sort of editing experience can be made seamless and fluid, moreso than raw text editing as the user has _less to specify_. And unlike raw text program editing, where all disambiguation of intent is syntax-directed, semantic editors may disambiguate intent via syntax, types, and/or interaction in the UI. Among other things, a consequence of this choice is that in Unison can get away with [no import statements](https://pchiusano.github.io/2015-02-23/unison-update3.html#import-boilerplate). The user also gets instantaneous feedback from the compiler, in the form of search and type-directed autocomplete and program search, and context-sensitive documentation and usage examples.
* _The codebase is a purely functional data structure_: In Unison, terms and types are uniquely identified by a nameless hash of their structure. References stored in the syntax tree are by hash, and human-readable names are separately stored metadata used only for display purposes by the editor. As in [Nix](https://nixos.org/nix/), the value associated with a hash never changes. "Modifying" a term creates a new term, with a new hash. This has far-ranging consequences, from much better support for large-scale refactoring, to trivial sharing of data _and functions_ across node boundaries in distributed systems.
* _The program is a UI, and UI interaction is programming_. Unison _panels_ take the idea of spreadsheets, which [blur the distinction between UI interaction and programming](http://pchiusano.github.io/2015-03-17/unison-update5.html), to its logical conclusion. We don't write a program to _produce_ a UI as output, we write a program which [_is viewed_ as a UI](http://pchiusano.github.io/2014-11-13/program-as-ui.html). Interaction with the UI is, quite literally, programming, though the user doesn't have to be aware of it. This model means we can solve problems of validation, autocomplete, and exquisitely context sensitive help _once_, in the Unison editor, and solve them in a principled way using the lens of programming languages and type systems, rather than [recreating this functionality in ad hoc ways for each and every UI we write](http://pchiusano.github.io/2013-05-22/future-of-software.html).
* _Persistent data sources must be accessible via a high-level, typed API._ Unison's architecture means that _all_ Unison values can be trivially (and efficiently) serialized and deserialized to a persistent store. No more having to discard all type information and invent ad hoc encodings for persistence of each and every business object to whatever data store. In addition to internally managed datasets, support is also planned for connections to external data sources, while retaining a high-level API that abstracts over the particulars of each source. Individuals and businesses will be able to hook Unison up to datasets they own, and if they wish, share access to these datasets with other nodes in the Unison web. In doing so they get access to all the reporting, visualization, and computational capabilities of the Unison language and its general-purpose editor.

These premises make many problems simpler and raise some new challenges. Here are just a few of the implications:

* Representing the codebase as a purely functional structure, with references done by immutable hash, means that renaming is a trivial refactoring which involves updating the metadata for a hash in a single location!
  * At the same time, since no function, type, or value, is ever modified _in place_, editing creates a new term, with a distinct hash, referenced nowhere. Propagating a change to the transitive set of dependents of an initial changeset is instead done via structured [_refactoring sessions_](https://pchiusano.github.io/2015-04-23/unison-update7.html#refactoring-sessions) rather than tedious and error-prone text munging.
* Since the value stored for a hash never changes, we can cache metadata about it like its type, and trivially do incremental typechecking in response to program edits. There is also no need to solve complicated problems of incremental reparsing, since there _is no parser_---the semantic editor directly constructs the syntax tree.
* Dependencies are tracked at the level of individual terms and types. A term does not depend on 'the statistics package', it depends on particular functions, uniquely identified by hashes of their content (metadata tags these functions as 'statistics' and gives them human readable names). This eliminates extraneous dependencies that come with tracking dependencies at more coarse-grained levels, a major cause of dependency hell.
* Since there is no global namespace, there are no conflicts whereby library A and library B disagree about what meaning to assign to a symbol (like if A and B depend on different, conflicting versions of some common library). It works just fine to write a function that uses bits from both library A and library B, indeed the very concept of a library or package becomes more fluid. A library is just a collection of hashes, and the same hash may be included in multiple libraries.
* Also as a result, Unison has a simple story for serialization and sharing of arbitrary terms, _including functions_. Two Unison nodes may freely exchange data and functions---when sending a value, each states the set of hashes that value depends on, and the receiving node requests transmission of any hashes it doesn't already know about. Using nameless, content-based hashes for references sidesteps complexities that arise due to the possibility that sender and receiver may each have different notions of what a particular symbol means (because they have different versions of some libraries, say).
* Running arbitrary C code received over the network would obviously be a huge security liability. But since Unison is purely functional and uses a safe runtime, executing functions sent over the network can be made safe---our main concern becomes how much CPU and memory resources to allot 'untrusted' code. This is much simpler to address compared to worrying about whether the code will erase your root directory, take over your machine, or monkey-patch some commonly used function in your codebase!
* The semantic editor supports [embedded graphical views](http://pchiusano.github.io/2014-11-13/program-as-ui.html) as well as 'reactive' values, so the user [can edit programs in a spreadsheet-like fashion](http://pchiusano.github.io/2013-05-22/future-of-software.html), with instantaneous feedback about how updates affect results. As a result, a unison editor session, called a _panel_, is suitable for defining real-time dashboards and other interactive UIs that we currently now write as one-off applications.
* Semantic editing facilitates usage by both nonprogrammers and beginners who may simply "fill in the blanks" using the editor's rich support for autocomplete, as well as expert programmers who can define completely new functionality and views using an editor with extremely rich tooling.
* Trivial sharing, and _linking to_ Unison panels, values, and types. A Unison panel is itself a Unison term, with a unique hash. Thus, Unison preserves an important aspect of the web: _linkability_. Any publicly available Unison node can expose the set of values it knows about, and others can link to and thus build upon functionality written by others. Unlike applications, Unison panels are a starting point for further composition and experimentation!

Are these things really all achievable? Yes!

### What's next?

* For more background, check out the [Unison tagged posts here](http://pchiusano.io/unison).
* Check out the latest [project status updates](/updates).
