---
layout: post
categories: [design, editor]
title: Designing a fluent interface to a semantic editor
post_author: Paul Chiusano
---

I'm at the point where I have all the machinery needed to start adding the ability to _edit_ as well as view Unison expressions in the editor. However, rather than diving right into implementation (which I [did before with the Elm-based version](http://pchiusano.github.io/2015-03-17/unison-update5.html)), I decided to take a step back and try to figure out a better story for fluent semantic editing.

Textual editing gives a feeling of directness and control. There's basically a one-to-one correspondence between the editing inputs (type the 'a' key), and the default rendering of the _model_ in response to those actions (the letter 'a' appearing in the editor). Like drawing a picture, painting, or sculpting clay, the user feels like they are creating via _direct manipulation_, without needing any deep training to get there. This is a good feeling to strive for even if raw textual editing isn't the medium used.

On the other end of the spectrum we have the _creation via external controls_, where one manipulates various knobs, switches, sliders, etc, whose effects on the model are nonobvious and require extensive training. Think of various software synthesizers, which are rather uncreatively modeled after real-life synths, down to the detailed [3D-ish rendering of individuals knobs and controls](https://www.propellerheads.se/substance/discovering-reason/index.cfm?article=part19&fuseaction=get_article). Just look at it, there are even _fake screws_ in the panels!!

But the situation is actually more nuanced. A better way to look at this is that _all_ ways of specifying information necessarily deal in symbols and encodings. According to this view, there's no such thing as direct manipulation, it's just that some symbolic encodings are close enough to an encoding we already know that there's less of a learning curve! For example:

* You might think that drawing on a page is direct manipulation of the image, but it's not. Your brain is doing a very complicated encoding of drawing actions to a stream of nerve firings, basically ones and zeros! It does the same thing on the receiving end, converting patterns of nerve firings from your eyeballs to perceived vision. Watch a small child learning to write or draw (or just think back to when you were little) and it's clear what a monumental learning task this all is. Most adults would give up if they ever had to learn anything so complicated. Drawing only feels like direct manipulation because the translation of thoughts to encoding of those thoughts to actions is done _subconciously and automatically_.
* I just dissed on the those software synthesizers above, but for someone trained in those programs, each of those knobs and switches has a very direct and understood effect, and an expert develops highly optimized pathways for converting this display of "meaningless symbols" to whatever mental structures are most useful for audio synthesis. Like any foreign language, with fluency, the language is translated into mental structures directly, without any conscious translation layer.
* Manipulating text to write programs might feel very direct, but only for someone who already knows how to type quickly, and who is fluent in understanding the textual representation of programs. And actually, much of text editing in tools like Vim or Emacs is very _indirect_. One learns a bevy of different key combinations and shortcuts to produce various effects, and it's only with time that these actions are so committed to muscle memory that use of the editor starts to feel like direct manipulation.

So the question isn't "should we use arbitrary encodings", it's "which arbitrary encoding can efficiently encode the interactions we want, and as a bonus is similar enough to some other known encoding that it's easier to learn". Let's look at a couple examples:

* For the [editor navigation controls](http://unisonweb.org/2015-09-17/directional-navigation.html#post-start), there are currently just a few actions: _up_, _down_, _left_, _right_, _expand_, _contract_, _leftmost_, and _rightmost_. (I'll add _search_ at some point too, and that's probably it.) This action set can efficiently encode any navigation in the editor, and leaning on the existing geometric intuitions the user has works well. Easy wins here are using the arrow keys to specify these movements, leveraging the existing encoding most users already have well established. (And also supporting home row `hjkl`-style navigation is easy too.) The one arbitrary part of the encoding requiring new learning is the _expand_ and _contract_ actions. Though these actions are easy to understand, there's no standardized keyboard input for them. But since they are somewhat analogous to _up_ and _down_, a good default might be `<shift>+<up>` and `<shift>+<down>`.
* Many "visual" programming languages attempt to make programming more accessible by letting the user create functions and expressions by connecting boxes and arrows. There are a couple problems with this. First: the information content of the display is extremely low. With a screenful of boxes and arrows, most of the space is occupied by content that has no real meaning---the function application `f x (y + 1)` might require three separate boxes, with arrows connecting them and enough surrounding whitespace to keep it from looking like a tangled mess. Specifying this diagram via direct manipulation might require 45 seconds and a mixture of mouse movement, clicking, and typing. Compare that to the few seconds it might take a good typist to type `f x (y + 1)`.
  * Another problem with boxes-and-arrows style interfaces is that they tend to be rather hostile toward abstraction, and one is encouraged to program in a very first-order style. What's the boxes-and-arrows notation for a higher-order function, parameterized on an arbitrary applicative functor? The notation simply doesn't scale very well to the sorts of more abstract programs that often form the majority of a real codebase.

Optimizing purely for speed of short term learning isn't a great goal. All else being equal, make things easier to learn, but long-term productivity is really important, especially for a tool a user is likely to invest a lot of time in.

__Aside:__ I dispute that boxes-and-arrows style interfaces are a good way to make programming more learnable. These sorts of interfaces solve a couple problems pretty well---they eliminate a large class of cryptic compile and/or runtime errors by having a more constrained UI. That's a good thing. But they end up creating other much worse problems. It's better to solve the problem of cryptic compile and/or runtime errors more directly, keeping a more-or-less textual entry mode and just constraining the UI to prevent the user from specifying ill-typed or ill-formed programs.

### Fluent semantic editing

I'm going to start just by listing off a set of primitive editing actions. Then I'll explore how to expose these actions to the user in a way that feels fluent and is easy to learn. You might want to watch [this old video](http://pchiusano.github.io/2015-03-17/unison-update5.html) to have some idea of what these actions could look like in the editor.

* `open path` - Opens the currently highlighted node for editing, which brings up the _explorer_. The editor is always in one of two modes - editing, or navigation. When in the navigation mode, the user has access to the navigations actions discussed above.
* `close` - Close the explorer and transition back to navigation mode, replacing the highlighted node with the expression selected in the explorer. I'm using the word "expression" more generally here, since we should be able to do the same sort of editing whether we are replacing a subterm of a Unison term, or modfying part of a type or type declaration, or editing the name of a symbol.
* `cancel` - Like `close`, but leave the highlighted expression in its original state.
* `filter` - Manipulate the contents of the explorer, by typing a query to filter down matching results, or by using the arrow keys or mouse to change what item is selected.
* Various refactoring actions which are guaranteed to keep the program well-typed. For instance:
  * Replace the current selection with its evaluated result. Example: `1 + 1` gets replaces in the editor with `2`.
  * Replace the current selection, `x`, with `_ x`, wrapped in a blank function call.
  * Introduce a new binding at the current scope. That is, `x` becomes `let z1923 = _ in x`.
* Various actions which _aren't_ guaranteed to keep the program well-typed. For instance, replacing the current selection `f` with `f _`, which is only safe if `f` is a function of some sort. Or replace the current selection `x` with `x + _`, which is only safe if `x` is a number of some sort.

This action set is sufficient, now how to make it feel fluent? Here are some thoughts:

There might be a lot of refactoring actions. We could just assign some arbitrary keyboard combo to every action. But that's a pretty steep learning curve. I'd give keyboard shortcuts to a couple important ones (like `eval` and introduce binding), and just use search for the rest. For instance, the 'float let binding out one level' refactoring action might not need a separate key-binding, just the ability to search for actions, or it can be triggered via a natural gesture like a click and drag while the binding is selected. Likewise for things like renaming---just editing the node where the variable is bound (like the `x` in the `x -> ...` lambda) should automatically rename.

This ability to search for actions seems to raise the need for a third mode. Or does it? Proliferation of modes is complicated and makes the UI harder to learn. Better to just co-opt the explorer for this. When the explorer comes up, applicable _replacement expressions_ as well as _actions_ will be shown, and filtering will search for both.

`open`, `close`, `cancel` and `filter` already feel pretty nice. Navigate around with the arrow keys or home keys, press enter to open the explorer, filter down results, enter again to accept. What isn't so nice is all the jumping back and forth between modes. For instance, to write the expression `f x (y + 1)`, we have to write `f`, select `f _ _` in the explorer, then move right, then enter to open the explorer to fill in the first blank, fill in `x`, hit enter, move right, hit enter again... that's a lot of mode-shifting and pressing enter. Another efficiency problem is that when the explorer is open, the user has a text box active, so `hjkl`-style navigation has to be disabled or accessed via a modifier of some sort. Jumping back and forth between the arrow keys and the home row for typing names of identifiers is a bit burdensome.

Switching modes is fine if you're making isolated edits here and there, but when you're entering in a large composite expression it gets a bit tedious. This leads to an idea: when the explorer is open, there should be an action for _accept and advance_, which accepts the current selection, navigates to the 'next' location, and reopens the explorer, all in one motion. In the old editor, I had a version of this triggered by simply typing two spaces. When it worked, it was pretty nice---you'd type enough letters of the identifier to make it the only selection (or you could keep typing out the full identifier if you wanted), then hit space twice and continue typing. The problem was that the 'next' location might not be the location you wanted to be, and now you had an explorer popped up in the wrong location that you needed to first close before you could navigate anywhere. Not very fluent.

Let's go back to thinking about text for a minute. With text, you can both edit and navigate within the same mode. You type an identifier name, move a few characters over, enter a number, a comma, move back a few characters, etc. Is this important? Maybe not---in Vim, I almost always Ctrl+C (with caps lock mapped to control) to exit insert mode before navigating, even if I'm moving over just a couple characters. The mode shift is so fast that it almost doesn't feel like anything, and many of the movements are using right-hand keys so a move left or right is a quick right-then-left _tap_ _tap_. It's all home row or close to the home row.

In contrast, pressing _enter_ feels like a huge interruption. It's just one key-width further, but you have to hit it with your pinky and bring your fingers off from their normal typing position.

Something else that's annoying about the mode switching is that the explorer keeps popping open and closing. Even if the mode switches are fast (perhaps ';' is mapped to the 'cancel' action in the explorer---as long as ';' can't be part of an identifier), visually, it's kind of distracting to have an explorer pop up in the wrong spot with a bunch of information you don't care about, only to be instantly dismissed.

This gives me several ideas:

* Design 1 (rejected): Rather than having 'accept and advance' pick a default next node for editing, which might not be the one the user wanted, instead let the user specify this explicitly. This doesn't work very well for a couple reasons:
  * Forcing the user to disambiguate is not likely to be more efficient than regular navigation mode, unless the list of options is very small.
  * Even if the list of options is very small, we are presenting a menu of options to the user in an order the user can't really predict in advance. The user has to now parse a menu of options, which effectively stalls any mental pipeline.
* Design 2: Optimize the mode transition key-bindings. 'o' for 'open' and ';' for cancel. Double space for accept and advance. But perhaps also, _keep the explorer view open and in a consistent location at all times_, rather than floating it next to the current selection. This avoids the distraction of it popping open and closing. Since we've optimized mode transition, even if we pick the wrong node to advance to, the user can easily make adjustments, and there's no visual distraction at the focal point of editing. What I don't like about this is needing to keep a block of the screen reserved at all times. Perhaps we can improve this by 'autohiding' the explorer when it goes unused for a few seconds. During rapid typing, with transitions back and forth between modes, it sticks to the top (or bottom) of the screen, but when you're done editing it slides away.
* Design 3: Double space for accept and advance, but _allow for navigation actions while in the editing mode_. This would solve the problem of entering the wrong node. The trouble is, when the explorer is open, a text field has focus, and we can't make use of any key the user might want to actually type. (I didn't feel bad about using ';' for cancel, since that's not likely going to be part of any identifier, but we definitely can't use 'hjkl') We also can't use the arrow keys. Left/right are needed to move the cursor in the explorer text box, and up/down are needed to move the explorer selection. So we're left with modifiers. I vote for Ctrl+hjkl (assuming the browser or OS will give us these events) and Shift+Up/Down/Left/Right. But at this point, needing to invoke modifiers isn't much more efficient than exiting explorer and reopening.
  * This gives me an idea. While in navigation mode, let's use 'release of the Shift key' to trigger the 'open' action. Here's an example use. The user does a double space to accept, then a quick cancel with ';', then simultaneously holds down shift and moves around a bit with 'hjkl', then releases the shift key.
  * Again let's make the explorer a little sticky, so it doesn't disappear immediately after closing. Perhaps a slow fade out?

Teasing this apart a bit further:

* A sticky explorer location raises some difficulties because its size changes depending on how much information is being displayed. For instance, after filtering, the number of selection items will decrease. Should we relow the content given this new size? If we do, that'd likely to be visually jarring, moreso that popping up the explorer, which occupies a separate layer and doesn't affect layout of anything that already exists.
* In general, the explorer shows information relevant to the currently selected node. Though it can be distracting, it makes the most sense to display this information as close to the current selection as possible, rather than in some external panel. I think this provides a greater sense of directness. The explorer is a bit like holding a magnifying glass up to some portion of the editor, which the user looks directly through.
* This is all pointing away from keeping the explorer in a fixed location and instead letting it float next to the highlighted selection. For modes that pertain to a specific entity, it's quite natural to put their view as close to that entity as possible. We can ease the difficulties with Design 2 just by:
  * Using 'o' or the shift key release to trigger the open action seems like a nice optimization. Likewise on using ';' for cancel.
  * Making the explorer a bit sticky, perhaps having it fade out slowly after close, rather than abruptly popping close and open.
  * Good use of visual design and cues, so actions of the explorer aren't too distracting if they are changing rapidly in response to user inputs.

Let's recap the full set of editor actions, which are simple enough to explain and demonstrate to just about anyone in 5-10 minutes:

* A small number of navigation actions: up, down, left, right, leftmost, rightmost, expand, contract, and (later) search.
* A single action, open, for transitioning from navigation mode to editing mode.
* A cancel action, for transitioning from editing mode to navigation mode, with no effect.
* An accept action, for transitioning from editing mode to navigation mode, with the effect of modifying the current selection. This is used for selecting both actions (like refactorings) and expressions for substitution.
* An accept-and-advance action, which might act like an accept, followed by a right movement, followed by an 'open'.

Crucially, if you have a fully-formed, well-typed program in your head and need no feedback from the compiler, there is never any point at which you are forced to parse any information in the explorer. Anything you type has a predictable-in-advance effect, and you can mentally pipeline the work you have to do, much like ordinary text editing.

Sounds promising, but there's only one way to know how it will feel, and that's to implement it!
